{"ast":null,"code":"(function (exports) {\n  crossfilter.version = \"1.3.12\";\n\n  function crossfilter_identity(d) {\n    return d;\n  }\n\n  crossfilter.permute = permute;\n\n  function permute(array, index) {\n    for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {\n      copy[i] = array[index[i]];\n    }\n\n    return copy;\n  }\n\n  var bisect = crossfilter.bisect = bisect_by(crossfilter_identity);\n  bisect.by = bisect_by;\n\n  function bisect_by(f) {\n    // Locate the insertion point for x in a to maintain sorted order. The\n    // arguments lo and hi may be used to specify a subset of the array which\n    // should be considered; by default the entire array is used. If x is already\n    // present in a, the insertion point will be before (to the left of) any\n    // existing entries. The return value is suitable for use as the first\n    // argument to `array.splice` assuming that a is already sorted.\n    //\n    // The returned insertion point i partitions the array a into two halves so\n    // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n    // a[i:hi] for the right side.\n    function bisectLeft(a, x, lo, hi) {\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (f(a[mid]) < x) lo = mid + 1;else hi = mid;\n      }\n\n      return lo;\n    } // Similar to bisectLeft, but returns an insertion point which comes after (to\n    // the right of) any existing entries of x in a.\n    //\n    // The returned insertion point i partitions the array into two halves so that\n    // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n    // a[i:hi] for the right side.\n\n\n    function bisectRight(a, x, lo, hi) {\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (x < f(a[mid])) hi = mid;else lo = mid + 1;\n      }\n\n      return lo;\n    }\n\n    bisectRight.right = bisectRight;\n    bisectRight.left = bisectLeft;\n    return bisectRight;\n  }\n\n  var heap = crossfilter.heap = heap_by(crossfilter_identity);\n  heap.by = heap_by;\n\n  function heap_by(f) {\n    // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n    // property such that the parent a[lo+i] is always less than or equal to its\n    // two children: a[lo+2*i+1] and a[lo+2*i+2].\n    function heap(a, lo, hi) {\n      var n = hi - lo,\n          i = (n >>> 1) + 1;\n\n      while (--i > 0) {\n        sift(a, i, n, lo);\n      }\n\n      return a;\n    } // Sorts the specified array a[lo:hi] in descending order, assuming it is\n    // already a heap.\n\n\n    function sort(a, lo, hi) {\n      var n = hi - lo,\n          t;\n\n      while (--n > 0) {\n        t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n      }\n\n      return a;\n    } // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n    // slice of array a[lo:lo+n]. This method can also be used to update the heap\n    // incrementally, without incurring the full cost of reconstructing the heap.\n\n\n    function sift(a, i, n, lo) {\n      var d = a[--lo + i],\n          x = f(d),\n          child;\n\n      while ((child = i << 1) <= n) {\n        if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n        if (x <= f(a[lo + child])) break;\n        a[lo + i] = a[lo + child];\n        i = child;\n      }\n\n      a[lo + i] = d;\n    }\n\n    heap.sort = sort;\n    return heap;\n  }\n\n  var heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);\n  heapselect.by = heapselect_by;\n\n  function heapselect_by(f) {\n    var heap = heap_by(f); // Returns a new array containing the top k elements in the array a[lo:hi].\n    // The returned array is not sorted, but maintains the heap property. If k is\n    // greater than hi - lo, then fewer than k elements will be returned. The\n    // order of elements in a is unchanged by this operation.\n\n    function heapselect(a, lo, hi, k) {\n      var queue = new Array(k = Math.min(hi - lo, k)),\n          min,\n          i,\n          x,\n          d;\n\n      for (i = 0; i < k; ++i) {\n        queue[i] = a[lo++];\n      }\n\n      heap(queue, 0, k);\n\n      if (lo < hi) {\n        min = f(queue[0]);\n\n        do {\n          if (x = f(d = a[lo]) > min) {\n            queue[0] = d;\n            min = f(heap(queue, 0, k)[0]);\n          }\n        } while (++lo < hi);\n      }\n\n      return queue;\n    }\n\n    return heapselect;\n  }\n\n  var insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);\n  insertionsort.by = insertionsort_by;\n\n  function insertionsort_by(f) {\n    function insertionsort(a, lo, hi) {\n      for (var i = lo + 1; i < hi; ++i) {\n        for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n          a[j] = a[j - 1];\n        }\n\n        a[j] = t;\n      }\n\n      return a;\n    }\n\n    return insertionsort;\n  } // Algorithm designed by Vladimir Yaroslavskiy.\n  // Implementation based on the Dart project; see lib/dart/LICENSE for details.\n\n\n  var quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);\n  quicksort.by = quicksort_by;\n\n  function quicksort_by(f) {\n    var insertionsort = insertionsort_by(f);\n\n    function sort(a, lo, hi) {\n      return (hi - lo < quicksort_sizeThreshold ? insertionsort : quicksort)(a, lo, hi);\n    }\n\n    function quicksort(a, lo, hi) {\n      // Compute the two pivots by looking at 5 elements.\n      var sixth = (hi - lo) / 6 | 0,\n          i1 = lo + sixth,\n          i5 = hi - 1 - sixth,\n          i3 = lo + hi - 1 >> 1,\n          // The midpoint.\n      i2 = i3 - sixth,\n          i4 = i3 + sixth;\n      var e1 = a[i1],\n          x1 = f(e1),\n          e2 = a[i2],\n          x2 = f(e2),\n          e3 = a[i3],\n          x3 = f(e3),\n          e4 = a[i4],\n          x4 = f(e4),\n          e5 = a[i5],\n          x5 = f(e5);\n      var t; // Sort the selected 5 elements using a sorting network.\n\n      if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n      if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n      if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n      if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n      if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n      if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n      if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n      if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n      if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n      var pivot1 = e2,\n          pivotValue1 = x2,\n          pivot2 = e4,\n          pivotValue2 = x4; // e2 and e4 have been saved in the pivot variables. They will be written\n      // back, once the partitioning is finished.\n\n      a[i1] = e1;\n      a[i2] = a[lo];\n      a[i3] = e3;\n      a[i4] = a[hi - 1];\n      a[i5] = e5;\n      var less = lo + 1,\n          // First element in the middle partition.\n      great = hi - 2; // Last element in the middle partition.\n      // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n      // Object.prototype.valueOf; == and === do not, so in order to be consistent\n      // with natural order (such as for Date objects), we must do two compares.\n\n      var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n\n      if (pivotsEqual) {\n        // Degenerated case where the partitioning becomes a dutch national flag\n        // problem.\n        //\n        // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n        //  ^             ^          ^             ^            ^\n        // left         less         k           great         right\n        //\n        // a[left] and a[right] are undefined and are filled after the\n        // partitioning.\n        //\n        // Invariants:\n        //   1) for x in ]left, less[ : x < pivot.\n        //   2) for x in [less, k[ : x == pivot.\n        //   3) for x in ]great, right[ : x > pivot.\n        for (var k = less; k <= great; ++k) {\n          var ek = a[k],\n              xk = f(ek);\n\n          if (xk < pivotValue1) {\n            if (k !== less) {\n              a[k] = a[less];\n              a[less] = ek;\n            }\n\n            ++less;\n          } else if (xk > pivotValue1) {\n            // Find the first element <= pivot in the range [k - 1, great] and\n            // put [:ek:] there. We know that such an element must exist:\n            // When k == less, then el3 (which is equal to pivot) lies in the\n            // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n            // Note that in the latter case invariant 2 will be violated for a\n            // short amount of time. The invariant will be restored when the\n            // pivots are put into their final positions.\n            while (true) {\n              var greatValue = f(a[great]);\n\n              if (greatValue > pivotValue1) {\n                great--; // This is the only location in the while-loop where a new\n                // iteration is started.\n\n                continue;\n              } else if (greatValue < pivotValue1) {\n                // Triple exchange.\n                a[k] = a[less];\n                a[less++] = a[great];\n                a[great--] = ek;\n                break;\n              } else {\n                a[k] = a[great];\n                a[great--] = ek; // Note: if great < k then we will exit the outer loop and fix\n                // invariant 2 (which we just violated).\n\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        // We partition the list into three parts:\n        //  1. < pivot1\n        //  2. >= pivot1 && <= pivot2\n        //  3. > pivot2\n        //\n        // During the loop we have:\n        // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n        //  ^            ^                        ^              ^             ^\n        // left         less                     k              great        right\n        //\n        // a[left] and a[right] are undefined and are filled after the\n        // partitioning.\n        //\n        // Invariants:\n        //   1. for x in ]left, less[ : x < pivot1\n        //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n        //   3. for x in ]great, right[ : x > pivot2\n        for (var k = less; k <= great; k++) {\n          var ek = a[k],\n              xk = f(ek);\n\n          if (xk < pivotValue1) {\n            if (k !== less) {\n              a[k] = a[less];\n              a[less] = ek;\n            }\n\n            ++less;\n          } else {\n            if (xk > pivotValue2) {\n              while (true) {\n                var greatValue = f(a[great]);\n\n                if (greatValue > pivotValue2) {\n                  great--;\n                  if (great < k) break; // This is the only location inside the loop where a new\n                  // iteration is started.\n\n                  continue;\n                } else {\n                  // a[great] <= pivot2.\n                  if (greatValue < pivotValue1) {\n                    // Triple exchange.\n                    a[k] = a[less];\n                    a[less++] = a[great];\n                    a[great--] = ek;\n                  } else {\n                    // a[great] >= pivot1.\n                    a[k] = a[great];\n                    a[great--] = ek;\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n        }\n      } // Move pivots into their final positions.\n      // We shrunk the list from both sides (a[left] and a[right] have\n      // meaningless values in them) and now we move elements from the first\n      // and third partition into these locations so that we can store the\n      // pivots.\n\n\n      a[lo] = a[less - 1];\n      a[less - 1] = pivot1;\n      a[hi - 1] = a[great + 1];\n      a[great + 1] = pivot2; // The list is now partitioned into three partitions:\n      // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n      //  ^            ^                        ^             ^\n      // left         less                     great        right\n      // Recursive descent. (Don't include the pivot values.)\n\n      sort(a, lo, less - 1);\n      sort(a, great + 2, hi);\n\n      if (pivotsEqual) {\n        // All elements in the second partition are equal to the pivot. No\n        // need to sort them.\n        return a;\n      } // In theory it should be enough to call _doSort recursively on the second\n      // partition.\n      // The Android source however removes the pivot elements from the recursive\n      // call if the second partition is too large (more than 2/3 of the list).\n\n\n      if (less < i1 && great > i5) {\n        var lessValue, greatValue;\n\n        while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) {\n          ++less;\n        }\n\n        while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) {\n          --great;\n        } // Copy paste of the previous 3-way partitioning with adaptions.\n        //\n        // We partition the list into three parts:\n        //  1. == pivot1\n        //  2. > pivot1 && < pivot2\n        //  3. == pivot2\n        //\n        // During the loop we have:\n        // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n        //              ^                      ^              ^\n        //            less                     k              great\n        //\n        // Invariants:\n        //   1. for x in [ *, less[ : x == pivot1\n        //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n        //   3. for x in ]great, * ] : x == pivot2\n\n\n        for (var k = less; k <= great; k++) {\n          var ek = a[k],\n              xk = f(ek);\n\n          if (xk <= pivotValue1 && xk >= pivotValue1) {\n            if (k !== less) {\n              a[k] = a[less];\n              a[less] = ek;\n            }\n\n            less++;\n          } else {\n            if (xk <= pivotValue2 && xk >= pivotValue2) {\n              while (true) {\n                var greatValue = f(a[great]);\n\n                if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n                  great--;\n                  if (great < k) break; // This is the only location inside the loop where a new\n                  // iteration is started.\n\n                  continue;\n                } else {\n                  // a[great] < pivot2.\n                  if (greatValue < pivotValue1) {\n                    // Triple exchange.\n                    a[k] = a[less];\n                    a[less++] = a[great];\n                    a[great--] = ek;\n                  } else {\n                    // a[great] == pivot1.\n                    a[k] = a[great];\n                    a[great--] = ek;\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n        }\n      } // The second partition has now been cleared of pivot elements and looks\n      // as follows:\n      // [  *  |  > pivot1 && < pivot2  | * ]\n      //        ^                      ^\n      //       less                  great\n      // Sort the second partition using recursive descent.\n      // The second partition looks as follows:\n      // [  *  |  >= pivot1 && <= pivot2  | * ]\n      //        ^                        ^\n      //       less                    great\n      // Simply sort it by recursive descent.\n\n\n      return sort(a, less, great + 1);\n    }\n\n    return sort;\n  }\n\n  var quicksort_sizeThreshold = 32;\n  var crossfilter_array8 = crossfilter_arrayUntyped,\n      crossfilter_array16 = crossfilter_arrayUntyped,\n      crossfilter_array32 = crossfilter_arrayUntyped,\n      crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped,\n      crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;\n\n  if (typeof Uint8Array !== \"undefined\") {\n    crossfilter_array8 = function crossfilter_array8(n) {\n      return new Uint8Array(n);\n    };\n\n    crossfilter_array16 = function crossfilter_array16(n) {\n      return new Uint16Array(n);\n    };\n\n    crossfilter_array32 = function crossfilter_array32(n) {\n      return new Uint32Array(n);\n    };\n\n    crossfilter_arrayLengthen = function crossfilter_arrayLengthen(array, length) {\n      if (array.length >= length) return array;\n      var copy = new array.constructor(length);\n      copy.set(array);\n      return copy;\n    };\n\n    crossfilter_arrayWiden = function crossfilter_arrayWiden(array, width) {\n      var copy;\n\n      switch (width) {\n        case 16:\n          copy = crossfilter_array16(array.length);\n          break;\n\n        case 32:\n          copy = crossfilter_array32(array.length);\n          break;\n\n        default:\n          throw new Error(\"invalid array width!\");\n      }\n\n      copy.set(array);\n      return copy;\n    };\n  }\n\n  function crossfilter_arrayUntyped(n) {\n    var array = new Array(n),\n        i = -1;\n\n    while (++i < n) {\n      array[i] = 0;\n    }\n\n    return array;\n  }\n\n  function crossfilter_arrayLengthenUntyped(array, length) {\n    var n = array.length;\n\n    while (n < length) {\n      array[n++] = 0;\n    }\n\n    return array;\n  }\n\n  function crossfilter_arrayWidenUntyped(array, width) {\n    if (width > 32) throw new Error(\"invalid array width!\");\n    return array;\n  }\n\n  function crossfilter_filterExact(bisect, value) {\n    return function (values) {\n      var n = values.length;\n      return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n    };\n  }\n\n  function crossfilter_filterRange(bisect, range) {\n    var min = range[0],\n        max = range[1];\n    return function (values) {\n      var n = values.length;\n      return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n    };\n  }\n\n  function crossfilter_filterAll(values) {\n    return [0, values.length];\n  }\n\n  function crossfilter_null() {\n    return null;\n  }\n\n  function crossfilter_zero() {\n    return 0;\n  }\n\n  function crossfilter_reduceIncrement(p) {\n    return p + 1;\n  }\n\n  function crossfilter_reduceDecrement(p) {\n    return p - 1;\n  }\n\n  function crossfilter_reduceAdd(f) {\n    return function (p, v) {\n      return p + +f(v);\n    };\n  }\n\n  function crossfilter_reduceSubtract(f) {\n    return function (p, v) {\n      return p - f(v);\n    };\n  }\n\n  exports.crossfilter = crossfilter;\n\n  function crossfilter() {\n    var crossfilter = {\n      add: add,\n      remove: removeData,\n      dimension: dimension,\n      groupAll: groupAll,\n      size: size\n    };\n    var data = [],\n        // the records\n    n = 0,\n        // the number of records; data.length\n    m = 0,\n        // a bit mask representing which dimensions are in use\n    M = 8,\n        // number of dimensions that can fit in `filters`\n    filters = crossfilter_array8(0),\n        // M bits per record; 1 is filtered out\n    filterListeners = [],\n        // when the filters change\n    dataListeners = [],\n        // when data is added\n    removeDataListeners = []; // when data is removed\n    // Adds the specified new records to this crossfilter.\n\n    function add(newData) {\n      var n0 = n,\n          n1 = newData.length; // If there's actually new data to add…\n      // Merge the new data into the existing data.\n      // Lengthen the filter bitset to handle the new records.\n      // Notify listeners (dimensions and groups) that new data is available.\n\n      if (n1) {\n        data = data.concat(newData);\n        filters = crossfilter_arrayLengthen(filters, n += n1);\n        dataListeners.forEach(function (l) {\n          l(newData, n0, n1);\n        });\n      }\n\n      return crossfilter;\n    } // Removes all records that match the current filters.\n\n\n    function removeData() {\n      var newIndex = crossfilter_index(n, n),\n          removed = [];\n\n      for (var i = 0, j = 0; i < n; ++i) {\n        if (filters[i]) newIndex[i] = j++;else removed.push(i);\n      } // Remove all matching records from groups.\n\n\n      filterListeners.forEach(function (l) {\n        l(0, [], removed);\n      }); // Update indexes.\n\n      removeDataListeners.forEach(function (l) {\n        l(newIndex);\n      }); // Remove old filters and data by overwriting.\n\n      for (var i = 0, j = 0, k; i < n; ++i) {\n        if (k = filters[i]) {\n          if (i !== j) filters[j] = k, data[j] = data[i];\n          ++j;\n        }\n      }\n\n      data.length = j;\n\n      while (n > j) {\n        filters[--n] = 0;\n      }\n    } // Adds a new dimension with the specified value accessor function.\n\n\n    function dimension(value) {\n      var dimension = {\n        filter: filter,\n        filterExact: filterExact,\n        filterRange: filterRange,\n        filterFunction: filterFunction,\n        filterAll: filterAll,\n        top: top,\n        bottom: bottom,\n        group: group,\n        groupAll: groupAll,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n\n      };\n      var one = ~m & -~m,\n          // lowest unset bit as mask, e.g., 00001000\n      zero = ~one,\n          // inverted one, e.g., 11110111\n      values,\n          // sorted, cached array\n      index,\n          // value rank ↦ object id\n      newValues,\n          // temporary array storing newly-added values\n      newIndex,\n          // temporary array storing newly-added index\n      sort = quicksort_by(function (i) {\n        return newValues[i];\n      }),\n          refilter = crossfilter_filterAll,\n          // for recomputing filter\n      refilterFunction,\n          // the custom filter function in use\n      indexListeners = [],\n          // when data is added\n      dimensionGroups = [],\n          lo0 = 0,\n          hi0 = 0; // Updating a dimension is a two-stage process. First, we must update the\n      // associated filters for the newly-added records. Once all dimensions have\n      // updated their filters, the groups are notified to update.\n\n      dataListeners.unshift(preAdd);\n      dataListeners.push(postAdd);\n      removeDataListeners.push(removeData); // Incorporate any existing data into this dimension, and make sure that the\n      // filter bitset is wide enough to handle the new dimension.\n\n      m |= one;\n\n      if (M >= 32 ? !one : m & -(1 << M)) {\n        filters = crossfilter_arrayWiden(filters, M <<= 1);\n      }\n\n      preAdd(data, 0, n);\n      postAdd(data, 0, n); // Incorporates the specified new records into this dimension.\n      // This function is responsible for updating filters, values, and index.\n\n      function preAdd(newData, n0, n1) {\n        // Permute new values into natural order using a sorted index.\n        newValues = newData.map(value);\n        newIndex = sort(crossfilter_range(n1), 0, n1);\n        newValues = permute(newValues, newIndex); // Bisect newValues to determine which new records are selected.\n\n        var bounds = refilter(newValues),\n            lo1 = bounds[0],\n            hi1 = bounds[1],\n            i;\n\n        if (refilterFunction) {\n          for (i = 0; i < n1; ++i) {\n            if (!refilterFunction(newValues[i], i)) filters[newIndex[i] + n0] |= one;\n          }\n        } else {\n          for (i = 0; i < lo1; ++i) {\n            filters[newIndex[i] + n0] |= one;\n          }\n\n          for (i = hi1; i < n1; ++i) {\n            filters[newIndex[i] + n0] |= one;\n          }\n        } // If this dimension previously had no data, then we don't need to do the\n        // more expensive merge operation; use the new values and index as-is.\n\n\n        if (!n0) {\n          values = newValues;\n          index = newIndex;\n          lo0 = lo1;\n          hi0 = hi1;\n          return;\n        }\n\n        var oldValues = values,\n            oldIndex = index,\n            i0 = 0,\n            i1 = 0; // Otherwise, create new arrays into which to merge new and old.\n\n        values = new Array(n);\n        index = crossfilter_index(n, n); // Merge the old and new sorted values, and old and new index.\n\n        for (i = 0; i0 < n0 && i1 < n1; ++i) {\n          if (oldValues[i0] < newValues[i1]) {\n            values[i] = oldValues[i0];\n            index[i] = oldIndex[i0++];\n          } else {\n            values[i] = newValues[i1];\n            index[i] = newIndex[i1++] + n0;\n          }\n        } // Add any remaining old values.\n\n\n        for (; i0 < n0; ++i0, ++i) {\n          values[i] = oldValues[i0];\n          index[i] = oldIndex[i0];\n        } // Add any remaining new values.\n\n\n        for (; i1 < n1; ++i1, ++i) {\n          values[i] = newValues[i1];\n          index[i] = newIndex[i1] + n0;\n        } // Bisect again to recompute lo0 and hi0.\n\n\n        bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n      } // When all filters have updated, notify index listeners of the new values.\n\n\n      function postAdd(newData, n0, n1) {\n        indexListeners.forEach(function (l) {\n          l(newValues, newIndex, n0, n1);\n        });\n        newValues = newIndex = null;\n      }\n\n      function removeData(reIndex) {\n        for (var i = 0, j = 0, k; i < n; ++i) {\n          if (filters[k = index[i]]) {\n            if (i !== j) values[j] = values[i];\n            index[j] = reIndex[k];\n            ++j;\n          }\n        }\n\n        values.length = j;\n\n        while (j < n) {\n          index[j++] = 0;\n        } // Bisect again to recompute lo0 and hi0.\n\n\n        var bounds = refilter(values);\n        lo0 = bounds[0], hi0 = bounds[1];\n      } // Updates the selected values based on the specified bounds [lo, hi].\n      // This implementation is used by all the public filter methods.\n\n\n      function filterIndexBounds(bounds) {\n        var lo1 = bounds[0],\n            hi1 = bounds[1];\n\n        if (refilterFunction) {\n          refilterFunction = null;\n          filterIndexFunction(function (d, i) {\n            return lo1 <= i && i < hi1;\n          });\n          lo0 = lo1;\n          hi0 = hi1;\n          return dimension;\n        }\n\n        var i,\n            j,\n            k,\n            added = [],\n            removed = []; // Fast incremental update based on previous lo index.\n\n        if (lo1 < lo0) {\n          for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n            filters[k = index[i]] ^= one;\n            added.push(k);\n          }\n        } else if (lo1 > lo0) {\n          for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n            filters[k = index[i]] ^= one;\n            removed.push(k);\n          }\n        } // Fast incremental update based on previous hi index.\n\n\n        if (hi1 > hi0) {\n          for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n            filters[k = index[i]] ^= one;\n            added.push(k);\n          }\n        } else if (hi1 < hi0) {\n          for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n            filters[k = index[i]] ^= one;\n            removed.push(k);\n          }\n        }\n\n        lo0 = lo1;\n        hi0 = hi1;\n        filterListeners.forEach(function (l) {\n          l(one, added, removed);\n        });\n        return dimension;\n      } // Filters this dimension using the specified range, value, or null.\n      // If the range is null, this is equivalent to filterAll.\n      // If the range is an array, this is equivalent to filterRange.\n      // Otherwise, this is equivalent to filterExact.\n\n\n      function filter(range) {\n        return range == null ? filterAll() : Array.isArray(range) ? filterRange(range) : typeof range === \"function\" ? filterFunction(range) : filterExact(range);\n      } // Filters this dimension to select the exact value.\n\n\n      function filterExact(value) {\n        return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));\n      } // Filters this dimension to select the specified range [lo, hi].\n      // The lower bound is inclusive, and the upper bound is exclusive.\n\n\n      function filterRange(range) {\n        return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));\n      } // Clears any filters on this dimension.\n\n\n      function filterAll() {\n        return filterIndexBounds((refilter = crossfilter_filterAll)(values));\n      } // Filters this dimension using an arbitrary function.\n\n\n      function filterFunction(f) {\n        refilter = crossfilter_filterAll;\n        filterIndexFunction(refilterFunction = f);\n        lo0 = 0;\n        hi0 = n;\n        return dimension;\n      }\n\n      function filterIndexFunction(f) {\n        var i,\n            k,\n            x,\n            added = [],\n            removed = [];\n\n        for (i = 0; i < n; ++i) {\n          if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) filters[k] &= zero, added.push(k);else filters[k] |= one, removed.push(k);\n          }\n        }\n\n        filterListeners.forEach(function (l) {\n          l(one, added, removed);\n        });\n      } // Returns the top K selected records based on this dimension's order.\n      // Note: observes this dimension's filter, unlike group and groupAll.\n\n\n      function top(k) {\n        var array = [],\n            i = hi0,\n            j;\n\n        while (--i >= lo0 && k > 0) {\n          if (!filters[j = index[i]]) {\n            array.push(data[j]);\n            --k;\n          }\n        }\n\n        return array;\n      } // Returns the bottom K selected records based on this dimension's order.\n      // Note: observes this dimension's filter, unlike group and groupAll.\n\n\n      function bottom(k) {\n        var array = [],\n            i = lo0,\n            j;\n\n        while (i < hi0 && k > 0) {\n          if (!filters[j = index[i]]) {\n            array.push(data[j]);\n            --k;\n          }\n\n          i++;\n        }\n\n        return array;\n      } // Adds a new group to this dimension, using the specified key function.\n\n\n      function group(key) {\n        var group = {\n          top: top,\n          all: all,\n          reduce: reduce,\n          reduceCount: reduceCount,\n          reduceSum: reduceSum,\n          order: order,\n          orderNatural: orderNatural,\n          size: size,\n          dispose: dispose,\n          remove: dispose // for backwards-compatibility\n\n        }; // Ensure that this group will be removed when the dimension is removed.\n\n        dimensionGroups.push(group);\n        var groups,\n            // array of {key, value}\n        groupIndex,\n            // object id ↦ group id\n        groupWidth = 8,\n            groupCapacity = crossfilter_capacity(groupWidth),\n            k = 0,\n            // cardinality\n        select,\n            heap,\n            reduceAdd,\n            reduceRemove,\n            reduceInitial,\n            update = crossfilter_null,\n            reset = crossfilter_null,\n            resetNeeded = true,\n            groupAll = key === crossfilter_null;\n        if (arguments.length < 1) key = crossfilter_identity; // The group listens to the crossfilter for when any dimension changes, so\n        // that it can update the associated reduce values. It must also listen to\n        // the parent dimension for when data is added, and compute new keys.\n\n        filterListeners.push(update);\n        indexListeners.push(add);\n        removeDataListeners.push(removeData); // Incorporate any existing data into the grouping.\n\n        add(values, index, 0, n); // Incorporates the specified new values into this group.\n        // This function is responsible for updating groups and groupIndex.\n\n        function add(newValues, newIndex, n0, n1) {\n          var oldGroups = groups,\n              reIndex = crossfilter_index(k, groupCapacity),\n              add = reduceAdd,\n              initial = reduceInitial,\n              k0 = k,\n              // old cardinality\n          i0 = 0,\n              // index of old group\n          i1 = 0,\n              // index of new record\n          j,\n              // object id\n          g0,\n              // old group\n          x0,\n              // old key\n          x1,\n              // new key\n          g,\n              // group to add\n          x; // key of group to add\n          // If a reset is needed, we don't need to update the reduce values.\n\n          if (resetNeeded) add = initial = crossfilter_null; // Reset the new groups (k is a lower bound).\n          // Also, make sure that groupIndex exists and is long enough.\n\n          groups = new Array(k), k = 0;\n          groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity); // Get the first old key (x0 of g0), if it exists.\n\n          if (k0) x0 = (g0 = oldGroups[0]).key; // Find the first new key (x1), skipping NaN keys.\n\n          while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) {\n            ++i1;\n          } // While new keys remain…\n\n\n          while (i1 < n1) {\n            // Determine the lesser of the two current keys; new and old.\n            // If there are no old keys remaining, then always add the new key.\n            if (g0 && x0 <= x1) {\n              g = g0, x = x0; // Record the new index of the old group.\n\n              reIndex[i0] = k; // Retrieve the next old key.\n\n              if (g0 = oldGroups[++i0]) x0 = g0.key;\n            } else {\n              g = {\n                key: x1,\n                value: initial()\n              }, x = x1;\n            } // Add the lesser group.\n\n\n            groups[k] = g; // Add any selected records belonging to the added group, while\n            // advancing the new key and populating the associated group index.\n\n            while (!(x1 > x)) {\n              groupIndex[j = newIndex[i1] + n0] = k;\n              if (!(filters[j] & zero)) g.value = add(g.value, data[j]);\n              if (++i1 >= n1) break;\n              x1 = key(newValues[i1]);\n            }\n\n            groupIncrement();\n          } // Add any remaining old groups that were greater than all new keys.\n          // No incremental reduce is needed; these groups have no new records.\n          // Also record the new index of the old group.\n\n\n          while (i0 < k0) {\n            groups[reIndex[i0] = k] = oldGroups[i0++];\n            groupIncrement();\n          } // If we added any new groups before any old groups,\n          // update the group index of all the old records.\n\n\n          if (k > i0) for (i0 = 0; i0 < n0; ++i0) {\n            groupIndex[i0] = reIndex[groupIndex[i0]];\n          } // Modify the update and reset behavior based on the cardinality.\n          // If the cardinality is less than or equal to one, then the groupIndex\n          // is not needed. If the cardinality is zero, then there are no records\n          // and therefore no groups to update or reset. Note that we also must\n          // change the registered listener to point to the new method.\n\n          j = filterListeners.indexOf(update);\n\n          if (k > 1) {\n            update = updateMany;\n            reset = resetMany;\n          } else {\n            if (!k && groupAll) {\n              k = 1;\n              groups = [{\n                key: null,\n                value: initial()\n              }];\n            }\n\n            if (k === 1) {\n              update = updateOne;\n              reset = resetOne;\n            } else {\n              update = crossfilter_null;\n              reset = crossfilter_null;\n            }\n\n            groupIndex = null;\n          }\n\n          filterListeners[j] = update; // Count the number of added groups,\n          // and widen the group index as needed.\n\n          function groupIncrement() {\n            if (++k === groupCapacity) {\n              reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);\n              groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);\n              groupCapacity = crossfilter_capacity(groupWidth);\n            }\n          }\n        }\n\n        function removeData() {\n          if (k > 1) {\n            var oldK = k,\n                oldGroups = groups,\n                seenGroups = crossfilter_index(oldK, oldK); // Filter out non-matches by copying matching group index entries to\n            // the beginning of the array.\n\n            for (var i = 0, j = 0; i < n; ++i) {\n              if (filters[i]) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            } // Reassemble groups including only those groups that were referred\n            // to by matching group index entries.  Note the new group index in\n            // seenGroups.\n\n\n            groups = [], k = 0;\n\n            for (i = 0; i < oldK; ++i) {\n              if (seenGroups[i]) {\n                seenGroups[i] = k++;\n                groups.push(oldGroups[i]);\n              }\n            }\n\n            if (k > 1) {\n              // Reindex the group index using seenGroups to find the new index.\n              for (var i = 0; i < j; ++i) {\n                groupIndex[i] = seenGroups[groupIndex[i]];\n              }\n            } else {\n              groupIndex = null;\n            }\n\n            filterListeners[filterListeners.indexOf(update)] = k > 1 ? (reset = resetMany, update = updateMany) : k === 1 ? (reset = resetOne, update = updateOne) : reset = update = crossfilter_null;\n          } else if (k === 1) {\n            if (groupAll) return;\n\n            for (var i = 0; i < n; ++i) {\n              if (filters[i]) return;\n            }\n\n            groups = [], k = 0;\n            filterListeners[filterListeners.indexOf(update)] = update = reset = crossfilter_null;\n          }\n        } // Reduces the specified selected or deselected records.\n        // This function is only used when the cardinality is greater than 1.\n\n\n        function updateMany(filterOne, added, removed) {\n          if (filterOne === one || resetNeeded) return;\n          var i, k, n, g; // Add the added values.\n\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (!(filters[k = added[i]] & zero)) {\n              g = groups[groupIndex[k]];\n              g.value = reduceAdd(g.value, data[k]);\n            }\n          } // Remove the removed values.\n\n\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if ((filters[k = removed[i]] & zero) === filterOne) {\n              g = groups[groupIndex[k]];\n              g.value = reduceRemove(g.value, data[k]);\n            }\n          }\n        } // Reduces the specified selected or deselected records.\n        // This function is only used when the cardinality is 1.\n\n\n        function updateOne(filterOne, added, removed) {\n          if (filterOne === one || resetNeeded) return;\n          var i,\n              k,\n              n,\n              g = groups[0]; // Add the added values.\n\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (!(filters[k = added[i]] & zero)) {\n              g.value = reduceAdd(g.value, data[k]);\n            }\n          } // Remove the removed values.\n\n\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if ((filters[k = removed[i]] & zero) === filterOne) {\n              g.value = reduceRemove(g.value, data[k]);\n            }\n          }\n        } // Recomputes the group reduce values from scratch.\n        // This function is only used when the cardinality is greater than 1.\n\n\n        function resetMany() {\n          var i, g; // Reset all group values.\n\n          for (i = 0; i < k; ++i) {\n            groups[i].value = reduceInitial();\n          } // Add any selected records.\n\n\n          for (i = 0; i < n; ++i) {\n            if (!(filters[i] & zero)) {\n              g = groups[groupIndex[i]];\n              g.value = reduceAdd(g.value, data[i]);\n            }\n          }\n        } // Recomputes the group reduce values from scratch.\n        // This function is only used when the cardinality is 1.\n\n\n        function resetOne() {\n          var i,\n              g = groups[0]; // Reset the singleton group values.\n\n          g.value = reduceInitial(); // Add any selected records.\n\n          for (i = 0; i < n; ++i) {\n            if (!(filters[i] & zero)) {\n              g.value = reduceAdd(g.value, data[i]);\n            }\n          }\n        } // Returns the array of group values, in the dimension's natural order.\n\n\n        function all() {\n          if (resetNeeded) reset(), resetNeeded = false;\n          return groups;\n        } // Returns a new array containing the top K group values, in reduce order.\n\n\n        function top(k) {\n          var top = select(all(), 0, groups.length, k);\n          return heap.sort(top, 0, top.length);\n        } // Sets the reduce behavior for this group to use the specified functions.\n        // This method lazily recomputes the reduce values, waiting until needed.\n\n\n        function reduce(add, remove, initial) {\n          reduceAdd = add;\n          reduceRemove = remove;\n          reduceInitial = initial;\n          resetNeeded = true;\n          return group;\n        } // A convenience method for reducing by count.\n\n\n        function reduceCount() {\n          return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n        } // A convenience method for reducing by sum(value).\n\n\n        function reduceSum(value) {\n          return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n        } // Sets the reduce order, using the specified accessor.\n\n\n        function order(value) {\n          select = heapselect_by(valueOf);\n          heap = heap_by(valueOf);\n\n          function valueOf(d) {\n            return value(d.value);\n          }\n\n          return group;\n        } // A convenience method for natural ordering by reduce value.\n\n\n        function orderNatural() {\n          return order(crossfilter_identity);\n        } // Returns the cardinality of this group, irrespective of any filters.\n\n\n        function size() {\n          return k;\n        } // Removes this group and associated event listeners.\n\n\n        function dispose() {\n          var i = filterListeners.indexOf(update);\n          if (i >= 0) filterListeners.splice(i, 1);\n          i = indexListeners.indexOf(add);\n          if (i >= 0) indexListeners.splice(i, 1);\n          i = removeDataListeners.indexOf(removeData);\n          if (i >= 0) removeDataListeners.splice(i, 1);\n          return group;\n        }\n\n        return reduceCount().orderNatural();\n      } // A convenience function for generating a singleton group.\n\n\n      function groupAll() {\n        var g = group(crossfilter_null),\n            all = g.all;\n        delete g.all;\n        delete g.top;\n        delete g.order;\n        delete g.orderNatural;\n        delete g.size;\n\n        g.value = function () {\n          return all()[0].value;\n        };\n\n        return g;\n      } // Removes this dimension and associated groups and event listeners.\n\n\n      function dispose() {\n        dimensionGroups.forEach(function (group) {\n          group.dispose();\n        });\n        var i = dataListeners.indexOf(preAdd);\n        if (i >= 0) dataListeners.splice(i, 1);\n        i = dataListeners.indexOf(postAdd);\n        if (i >= 0) dataListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        m &= zero;\n        return filterAll();\n      }\n\n      return dimension;\n    } // A convenience method for groupAll on a dummy dimension.\n    // This implementation can be optimized since it always has cardinality 1.\n\n\n    function groupAll() {\n      var group = {\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        value: value,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n\n      };\n      var reduceValue,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          resetNeeded = true; // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the reduce value. It must also listen to the parent\n      // dimension for when data is added.\n\n      filterListeners.push(update);\n      dataListeners.push(add); // For consistency; actually a no-op since resetNeeded is true.\n\n      add(data, 0, n); // Incorporates the specified new values into this group.\n\n      function add(newData, n0) {\n        var i;\n        if (resetNeeded) return; // Add the added values.\n\n        for (i = n0; i < n; ++i) {\n          if (!filters[i]) {\n            reduceValue = reduceAdd(reduceValue, data[i]);\n          }\n        }\n      } // Reduces the specified selected or deselected records.\n\n\n      function update(filterOne, added, removed) {\n        var i, k, n;\n        if (resetNeeded) return; // Add the added values.\n\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!filters[k = added[i]]) {\n            reduceValue = reduceAdd(reduceValue, data[k]);\n          }\n        } // Remove the removed values.\n\n\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters[k = removed[i]] === filterOne) {\n            reduceValue = reduceRemove(reduceValue, data[k]);\n          }\n        }\n      } // Recomputes the group reduce value from scratch.\n\n\n      function reset() {\n        var i;\n        reduceValue = reduceInitial();\n\n        for (i = 0; i < n; ++i) {\n          if (!filters[i]) {\n            reduceValue = reduceAdd(reduceValue, data[i]);\n          }\n        }\n      } // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce value, waiting until needed.\n\n\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      } // A convenience method for reducing by count.\n\n\n      function reduceCount() {\n        return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n      } // A convenience method for reducing by sum(value).\n\n\n      function reduceSum(value) {\n        return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n      } // Returns the computed reduce value.\n\n\n      function value() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return reduceValue;\n      } // Removes this group and associated event listeners.\n\n\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i);\n        i = dataListeners.indexOf(add);\n        if (i >= 0) dataListeners.splice(i);\n        return group;\n      }\n\n      return reduceCount();\n    } // Returns the number of records in this crossfilter, irrespective of any filters.\n\n\n    function size() {\n      return n;\n    }\n\n    return arguments.length ? add(arguments[0]) : crossfilter;\n  } // Returns an array of size n, big enough to store ids up to m.\n\n\n  function crossfilter_index(n, m) {\n    return (m < 0x101 ? crossfilter_array8 : m < 0x10001 ? crossfilter_array16 : crossfilter_array32)(n);\n  } // Constructs a new array of size n, with sequential values from 0 to n - 1.\n\n\n  function crossfilter_range(n) {\n    var range = crossfilter_index(n, n);\n\n    for (var i = -1; ++i < n;) {\n      range[i] = i;\n    }\n\n    return range;\n  }\n\n  function crossfilter_capacity(w) {\n    return w === 8 ? 0x100 : w === 16 ? 0x10000 : 0x100000000;\n  }\n})(typeof exports !== 'undefined' && exports || this);","map":{"version":3,"sources":["/Volumes/Study/CS/React JS/app/node_modules/crossfilter/crossfilter.js"],"names":["exports","crossfilter","version","crossfilter_identity","d","permute","array","index","i","n","length","copy","Array","bisect","bisect_by","by","f","bisectLeft","a","x","lo","hi","mid","bisectRight","right","left","heap","heap_by","sift","sort","t","child","heapselect","heapselect_by","k","queue","Math","min","insertionsort","insertionsort_by","j","quicksort","quicksort_by","quicksort_sizeThreshold","sixth","i1","i5","i3","i2","i4","e1","x1","e2","x2","e3","x3","e4","x4","e5","x5","pivot1","pivotValue1","pivot2","pivotValue2","less","great","pivotsEqual","ek","xk","greatValue","lessValue","crossfilter_array8","crossfilter_arrayUntyped","crossfilter_array16","crossfilter_array32","crossfilter_arrayLengthen","crossfilter_arrayLengthenUntyped","crossfilter_arrayWiden","crossfilter_arrayWidenUntyped","Uint8Array","Uint16Array","Uint32Array","constructor","set","width","Error","crossfilter_filterExact","value","values","crossfilter_filterRange","range","max","crossfilter_filterAll","crossfilter_null","crossfilter_zero","crossfilter_reduceIncrement","p","crossfilter_reduceDecrement","crossfilter_reduceAdd","v","crossfilter_reduceSubtract","add","remove","removeData","dimension","groupAll","size","data","m","M","filters","filterListeners","dataListeners","removeDataListeners","newData","n0","n1","concat","forEach","l","newIndex","crossfilter_index","removed","push","filter","filterExact","filterRange","filterFunction","filterAll","top","bottom","group","dispose","one","zero","newValues","refilter","refilterFunction","indexListeners","dimensionGroups","lo0","hi0","unshift","preAdd","postAdd","map","crossfilter_range","bounds","lo1","hi1","oldValues","oldIndex","i0","reIndex","filterIndexBounds","filterIndexFunction","added","isArray","key","all","reduce","reduceCount","reduceSum","order","orderNatural","groups","groupIndex","groupWidth","groupCapacity","crossfilter_capacity","select","reduceAdd","reduceRemove","reduceInitial","update","reset","resetNeeded","arguments","oldGroups","initial","k0","g0","x0","g","groupIncrement","indexOf","updateMany","resetMany","updateOne","resetOne","oldK","seenGroups","filterOne","valueOf","splice","reduceValue","w"],"mappings":"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","sourcesContent":["(function(exports){\ncrossfilter.version = \"1.3.12\";\nfunction crossfilter_identity(d) {\n  return d;\n}\ncrossfilter.permute = permute;\n\nfunction permute(array, index) {\n  for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\nvar bisect = crossfilter.bisect = bisect_by(crossfilter_identity);\n\nbisect.by = bisect_by;\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\nvar heap = crossfilter.heap = heap_by(crossfilter_identity);\n\nheap.by = heap_by;\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\nvar heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);\n\nheapselect.by = heapselect_by;\n\nfunction heapselect_by(f) {\n  var heap = heap_by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        x,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (x = f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\nvar insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);\n\ninsertionsort.by = insertionsort_by;\n\nfunction insertionsort_by(f) {\n\n  function insertionsort(a, lo, hi) {\n    for (var i = lo + 1; i < hi; ++i) {\n      for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n        a[j] = a[j - 1];\n      }\n      a[j] = t;\n    }\n    return a;\n  }\n\n  return insertionsort;\n}\n// Algorithm designed by Vladimir Yaroslavskiy.\n// Implementation based on the Dart project; see lib/dart/LICENSE for details.\n\nvar quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);\n\nquicksort.by = quicksort_by;\n\nfunction quicksort_by(f) {\n  var insertionsort = insertionsort_by(f);\n\n  function sort(a, lo, hi) {\n    return (hi - lo < quicksort_sizeThreshold\n        ? insertionsort\n        : quicksort)(a, lo, hi);\n  }\n\n  function quicksort(a, lo, hi) {\n    // Compute the two pivots by looking at 5 elements.\n    var sixth = (hi - lo) / 6 | 0,\n        i1 = lo + sixth,\n        i5 = hi - 1 - sixth,\n        i3 = lo + hi - 1 >> 1,  // The midpoint.\n        i2 = i3 - sixth,\n        i4 = i3 + sixth;\n\n    var e1 = a[i1], x1 = f(e1),\n        e2 = a[i2], x2 = f(e2),\n        e3 = a[i3], x3 = f(e3),\n        e4 = a[i4], x4 = f(e4),\n        e5 = a[i5], x5 = f(e5);\n\n    var t;\n\n    // Sort the selected 5 elements using a sorting network.\n    if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n    if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n    if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n    if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n\n    var pivot1 = e2, pivotValue1 = x2,\n        pivot2 = e4, pivotValue2 = x4;\n\n    // e2 and e4 have been saved in the pivot variables. They will be written\n    // back, once the partitioning is finished.\n    a[i1] = e1;\n    a[i2] = a[lo];\n    a[i3] = e3;\n    a[i4] = a[hi - 1];\n    a[i5] = e5;\n\n    var less = lo + 1,   // First element in the middle partition.\n        great = hi - 2;  // Last element in the middle partition.\n\n    // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n    // Object.prototype.valueOf; == and === do not, so in order to be consistent\n    // with natural order (such as for Date objects), we must do two compares.\n    var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n    if (pivotsEqual) {\n\n      // Degenerated case where the partitioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (var k = less; k <= great; ++k) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else if (xk > pivotValue1) {\n\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ek:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          while (true) {\n            var greatValue = f(a[great]);\n            if (greatValue > pivotValue1) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (greatValue < pivotValue1) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ek;\n              break;\n            } else {\n              a[k] = a[great];\n              a[great--] = ek;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else {\n          if (xk > pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue > pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[lo] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[hi - 1] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don't include the pivot values.)\n    sort(a, lo, less - 1);\n    sort(a, great + 2, hi);\n\n    if (pivotsEqual) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return a;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < i1 && great > i5) {\n      var lessValue, greatValue;\n      while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) ++less;\n      while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) --great;\n\n      // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk <= pivotValue1 && xk >= pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          less++;\n        } else {\n          if (xk <= pivotValue2 && xk >= pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // The second partition has now been cleared of pivot elements and looks\n    // as follows:\n    // [  *  |  > pivot1 && < pivot2  | * ]\n    //        ^                      ^\n    //       less                  great\n    // Sort the second partition using recursive descent.\n\n    // The second partition looks as follows:\n    // [  *  |  >= pivot1 && <= pivot2  | * ]\n    //        ^                        ^\n    //       less                    great\n    // Simply sort it by recursive descent.\n\n    return sort(a, less, great + 1);\n  }\n\n  return sort;\n}\n\nvar quicksort_sizeThreshold = 32;\nvar crossfilter_array8 = crossfilter_arrayUntyped,\n    crossfilter_array16 = crossfilter_arrayUntyped,\n    crossfilter_array32 = crossfilter_arrayUntyped,\n    crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped,\n    crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;\n\nif (typeof Uint8Array !== \"undefined\") {\n  crossfilter_array8 = function(n) { return new Uint8Array(n); };\n  crossfilter_array16 = function(n) { return new Uint16Array(n); };\n  crossfilter_array32 = function(n) { return new Uint32Array(n); };\n\n  crossfilter_arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  crossfilter_arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = crossfilter_array16(array.length); break;\n      case 32: copy = crossfilter_array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction crossfilter_arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\nfunction crossfilter_filterExact(bisect, value) {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nfunction crossfilter_filterRange(bisect, range) {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nfunction crossfilter_filterAll(values) {\n  return [0, values.length];\n}\nfunction crossfilter_null() {\n  return null;\n}\nfunction crossfilter_zero() {\n  return 0;\n}\nfunction crossfilter_reduceIncrement(p) {\n  return p + 1;\n}\n\nfunction crossfilter_reduceDecrement(p) {\n  return p - 1;\n}\n\nfunction crossfilter_reduceAdd(f) {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nfunction crossfilter_reduceSubtract(f) {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\nexports.crossfilter = crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      m = 0, // a bit mask representing which dimensions are in use\n      M = 8, // number of dimensions that can fit in `filters`\n      filters = crossfilter_array8(0), // M bits per record; 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = []; // when data is removed\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters = crossfilter_arrayLengthen(filters, n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters.\n  function removeData() {\n    var newIndex = crossfilter_index(n, n),\n        removed = [];\n    for (var i = 0, j = 0; i < n; ++i) {\n      if (filters[i]) newIndex[i] = j++;\n      else removed.push(i);\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(0, [], removed); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var i = 0, j = 0, k; i < n; ++i) {\n      if (k = filters[i]) {\n        if (i !== j) filters[j] = k, data[j] = data[i];\n        ++j;\n      }\n    }\n    data.length = j;\n    while (n > j) filters[--n] = 0;\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value) {\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var one = ~m & -~m, // lowest unset bit as mask, e.g., 00001000\n        zero = ~one, // inverted one, e.g., 11110111\n        values, // sorted, cached array\n        index, // value rank ↦ object id\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        sort = quicksort_by(function(i) { return newValues[i]; }),\n        refilter = crossfilter_filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Incorporate any existing data into this dimension, and make sure that the\n    // filter bitset is wide enough to handle the new dimension.\n    m |= one;\n    if (M >= 32 ? !one : m & -(1 << M)) {\n      filters = crossfilter_arrayWiden(filters, M <<= 1);\n    }\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n\n      // Permute new values into natural order using a sorted index.\n      newValues = newData.map(value);\n      newIndex = sort(crossfilter_range(n1), 0, n1);\n      newValues = permute(newValues, newIndex);\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1], i;\n      if (refilterFunction) {\n        for (i = 0; i < n1; ++i) {\n          if (!refilterFunction(newValues[i], i)) filters[newIndex[i] + n0] |= one;\n        }\n      } else {\n        for (i = 0; i < lo1; ++i) filters[newIndex[i] + n0] |= one;\n        for (i = hi1; i < n1; ++i) filters[newIndex[i] + n0] |= one;\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n      var oldValues = values,\n          oldIndex = index,\n          i0 = 0,\n          i1 = 0;\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = new Array(n);\n      index = crossfilter_index(n, n);\n\n      // Merge the old and new sorted values, and old and new index.\n      for (i = 0; i0 < n0 && i1 < n1; ++i) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[i] = oldValues[i0];\n          index[i] = oldIndex[i0++];\n        } else {\n          values[i] = newValues[i1];\n          index[i] = newIndex[i1++] + n0;\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++i) {\n        values[i] = oldValues[i0];\n        index[i] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++i) {\n        values[i] = newValues[i1];\n        index[i] = newIndex[i1] + n0;\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      for (var i = 0, j = 0, k; i < n; ++i) {\n        if (filters[k = index[i]]) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[k];\n          ++j;\n        }\n      }\n      values.length = j;\n      while (j < n) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; });\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [];\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, added, removed); });\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      return filterIndexBounds((refilter = crossfilter_filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      refilter = crossfilter_filterAll;\n\n      filterIndexFunction(refilterFunction = f);\n\n      lo0 = 0;\n      hi0 = n;\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [];\n\n      for (i = 0; i < n; ++i) {\n        if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n          if (x) filters[k] &= zero, added.push(k);\n          else filters[k] |= one, removed.push(k);\n        }\n      }\n      filterListeners.forEach(function(l) { l(one, added, removed); });\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k) {\n      var array = [],\n          i = hi0,\n          j;\n\n      while (--i >= lo0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k) {\n      var array = [],\n          i = lo0,\n          j;\n\n      while (i < hi0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = crossfilter_capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = crossfilter_null,\n          reset = crossfilter_null,\n          resetNeeded = true,\n          groupAll = key === crossfilter_null;\n\n      if (arguments.length < 1) key = crossfilter_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n        var oldGroups = groups,\n            reIndex = crossfilter_index(k, groupCapacity),\n            add = reduceAdd,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = crossfilter_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            if (g0 = oldGroups[++i0]) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n          while (!(x1 > x)) {\n            groupIndex[j = newIndex[i1] + n0] = k;\n            if (!(filters[j] & zero)) g.value = add(g.value, data[j]);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater than all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if (k > i0) for (i0 = 0; i0 < n0; ++i0) {\n          groupIndex[i0] = reIndex[groupIndex[i0]];\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = crossfilter_null;\n            reset = crossfilter_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if (++k === groupCapacity) {\n            reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);\n            groupCapacity = crossfilter_capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData() {\n        if (k > 1) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = crossfilter_index(oldK, oldK);\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          for (var i = 0, j = 0; i < n; ++i) {\n            if (filters[i]) {\n              seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n              ++j;\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1) {\n            // Reindex the group index using seenGroups to find the new index.\n            for (var i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = crossfilter_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var i = 0; i < n; ++i) if (filters[i]) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = crossfilter_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      function updateMany(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g;\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      function updateOne(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = heapselect_by(valueOf);\n        heap = heap_by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(crossfilter_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(crossfilter_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      m &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = n0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, added, removed) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (!filters[k = added[i]]) {\n          reduceValue = reduceAdd(reduceValue, data[k]);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters[k = removed[i]] === filterOne) {\n          reduceValue = reduceRemove(reduceValue, data[k]);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      for (i = 0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction crossfilter_index(n, m) {\n  return (m < 0x101\n      ? crossfilter_array8 : m < 0x10001\n      ? crossfilter_array16\n      : crossfilter_array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction crossfilter_range(n) {\n  var range = crossfilter_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction crossfilter_capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n})(typeof exports !== 'undefined' && exports || this);\n"]},"metadata":{},"sourceType":"script"}